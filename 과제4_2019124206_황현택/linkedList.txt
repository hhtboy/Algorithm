연결 리스트
	-지금까지 자료는 배열을 기반으로 함
		<배열의 문제>
			데이터를 순차적으로 넣을 수 밖에 없음 (사이에 넣으려면 shift로 배열을 밀어줘야 했음) -> 연결 리스트로 해결
	
	<단순 연결 리스트>
		배열 : 리스트의 일종, 순서가 있음,  삽입 삭제가 곤란
		리스트 : 원소들의 저장 순서 != 리스트 표현 순서
				 포인터를 이용해 연결
	    체인 : 단순 연결 리스트
		노드 : 체인의 하나의 연결 고리/ 데이터&다음 데이터를 가리키는 포인터로 구성
		
		-시작하는 first 포인터가 필요.
		
		삽입 : 새로운 노드 x, 전 노드의 link값은 x의 포인터를 저장 하고, x의 link는 후 노드의 포인터를 저장
		삭제 : 삭제 노드를 x라 하면, x노드 전의 link는 x 뒤의 포인터를 저장, x노드는 delete를 통해 메모리 확보
		x = NULL  -->  아무것도 안 가리킨다.

	<포인터 지정>
		x = first : x와 first가 가리키는 값이 같음
		*x = *first : data와 link값 모두 가져오게 됨. recersive 한 문제가 생긴다.

	<c++ 체인 표현>
		하나의 노드는 하나의 객체
		

	-트리나 그래프에 사용하는 비순차 자료구조이다.

	<체인 클래스 설계>
		리스트의 데이터, 링크에 접근하기 어려움
			1. public으로 선언 : 캡슐화 위배
			2. public 함수로써 접근 : 단순히 값을 바꾸기 위한 get함수 / set함수는 public으로 변수를 선언하는 것과 다를 것이 없음
			3. HAS-A : A가 B를 가지고 있다.(Car HAS-A Engine) / 복합 클래스(complex)
				-원래는 체인이 모든 노드를 HAS-A 관계를 가져야 하지만, 리스트의 가변적인 장점을 살리기 위해
				-체인에 first 노드만 넣게 된다. -> first노드로 다음 노드로 연결되어 접근할 수 있음.
				-체인을 노드의 friend로 선언(체인에서 노드를 사용할 수 있음 : 노드쪽에서 체인을 friend로 선언)
			4. nested 클래스(중첩 클래스) : 노드 객체가 체인 외부에서 접근할 수 없게 보장
				-노드 멤버는 public, 체인 안에 노드 클래스를 정의함으로써 체인 밖에서는 노드에 접근 불가
				-체인의 private멤버에 노드를 선언
				-복합 클래스와 다르게 중첩 클래스로 만들 경우 외부에서 노드객체를 사용할 수 없다는 차이가 있음
	<노드 만드는 순서>
		1.다음 노드를 만든다
		2. 현재 노드가 다음 노드를 가리키게 한다
		3. 
	<insert 노드>
		x가 존재한다고 가정
		(중요)노드를 연결할 때는 반드시 먼저 노드를 붙잡아 둬야한다
			- 뒤에 연결을 먼저 해주고 나서 앞에 연결을 한다.
	<delete 노드>
		1. x,y가 주어짐(x : 삭제할 노드, y : x 앞 노드)
			x,y가 존재할 지, 존재하지 않을 지 경우를 4가지로 나눠서 시작한다.(정확히는 x,y =0은 제외 / x가 존재하지 않고 y가 존재할 순 없으므로 2가지 경우)
		2. y만 주어짐(y : 삭제할 노드의 앞 노드)
			y->link = y->link->link
			delete y->link
			로 간단하다.
		3. x만 주어짐(x : 삭제할 노드)
			y를 찾아야함 : first부터 y까지 찾아와야함.
				if(f == y ) / if( f-> link == y) / ...
				r = f / while(r == y) r = r -> link
			
	<template 클래스 체인>
		어떤 타입이 오더라도 범용적으로 작동할 수 있는 모듈을 만들어야 한다. -> 좋은 반복자(순회 방법)을 사용해야 한다 
		[반복자 / iterator]
			1. 대입연산자 '=' 
			2. 비교연산자 '!= / =' 
			3. 사후/사전 증가 연산자 '++'
			4. 출력 연산자 "<<"
			5. 역참조 연산자 '*' 

	<iterator>
		위의 5가지 연산에 대해 오버로딩을 구현한다.


		추가 멤버 함수 :
			원하는 위치로 이동하는 begin,end 함수
			accumulate

		sum 함수:
			체인을 받아오고(list) list와 관련있는 Iterator를 만들어 준다

		for문에서 사용하기 위해 만듦

	<체인 연산>
		InsertBack() :
			first와 last를 기억하면 편하기 때문에 last를 체인에 추가한다.
			first 확인을 하고 공백이 아니라면, 노드를 추가

		Concatenate(체인 연결) :
			앞에 체인이 존재하는지 확인하고, 링크를 연결한 뒤 last를 바꿔준다
			뒤의 체인은 삭제
			last가 없다면?
				1. a의 last를 찾는다( iterator 이용)
				2. 나머지는 동일

		체인 역순으로 변환 :
			만약 배열이었다면 swap함수를 이용해서 n/2번 만큼 간단하게 바꾸면 됨
			어떤 작업이 필요할 지 파악하고 배열을 사용할 지, list를 사용할 지 결정(이 경우 배열이 간편하다)
			r / previous / current 필요
			왼쪽에서 오른쪽으로 가야함
			previous->link  = r; //실제 일하는 코드
			r, previous, current 한 칸씩 전진
			

--------------------------------------------------------------------------------------------------------
원형 리스트

	last->link = first

	- 리스트 맨 앞에 노드 삽입
		1. last 찾기
		newnode->link = last->link (last의 링크를 사용할 수 있기 때문에 first를 사용하지 않는다)
		last->link = newnode
		first = newnode

	- 헤더 노드 사용
		공백 노드 or  약속해 놓은 값을 집어넣음
		연산량이 절반으로 줄어듬 -> tradeoff (공간 복잡도를 아주 조금 늘려서 시간 복잡도를 절반으로 줄임)

가용공간 리스트
	
	메모리는 delete(release)를 해도, 이미 사용한 메모리공간을 사용할 수 없다.
	삭제된 노드를 체인으로 유지하고, 새로운 노드를 이 리스트에서 할당
	공동으로 사용하는 가용공간 리스트를 만들고, 필요할 때 노드를 꺼내준다.
	노드가 필요하면, new로 바로 할당하지 않고, 가져올 수 있는 노드가 있다면 가져온다.
	노드가 여러개 필요하면, 파라미터 int n을 준다.
	
	원형리스트의 일괄 제거
		파괴자에 delete를 사용하지 않고, av를 연결해서 하나의 리스트로 연결


	

--------------------------------------------------------------------------------------------------------

연결 스택과 큐

	<스택>
		push : 새로운 노드를 하나 만들고 top으로 지정
		pop : 삭제할 top의 위치를 저장해두고, top을 내리고, 저장해둔 노드를 해방(가용 리스트에 집어넣음)

	<큐>
		push : 노드를 붙이고 rear 수정(새로운 노드를 생성하고 연결)
		pop : front를 저장해두고, front를 당긴 뒤, 저장해 둔 노드 해방(가용 리스트에 집어넣음)
		

	<다항식>
		data : 계수와 지수를 가진 term 클래스가 노드의 data가 된다.
		[다항식 덧셈 오버로딩]
			if(sum) InsertBack();
		[다항식 곱셈 오버로딩]
		
		*중간에 사용한 재료(다항식) 처리 --> delete / avlist

		[다항식 원형리스트]
			f(x) = 0 을 예외처리 --> header node 사용(지수 자리에 -1을 넣음)
			헤더노드를 가지게 되면, 한가지 다항식을 다 돌았을 때, 두 번의 while 문을 돌 필요 없이 지수를 -1로 처리해서 해결할 수 있다.
			복잡도는 O(m+n)으로 똑같지만, 코드가 간단해짐.

